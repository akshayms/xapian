<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.5.9">
  <compounddef id="classXapian_1_1QueryParser" kind="class" prot="public">
    <compoundname>Xapian::QueryParser</compoundname>
    <includes local="no">queryparser.h</includes>
      <sectiondef kind="public-type">
      <memberdef kind="enum" id="classXapian_1_1QueryParser_1e96a58a8de9d219ca3214a5a66e0407e" prot="public" static="no">
        <name>feature_flag</name>
        <enumvalue id="classXapian_1_1QueryParser_1e96a58a8de9d219ca3214a5a66e0407effc56acef4c5b0da425d4ea74b7affde" prot="public">
          <name>FLAG_BOOLEAN</name>
          <initializer> 1</initializer>
          <briefdescription>
<para>Support AND, OR, etc and bracketed subexpressions. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="classXapian_1_1QueryParser_1e96a58a8de9d219ca3214a5a66e0407ed7e3ef99f48e26f40836a2e98ac86e6b" prot="public">
          <name>FLAG_PHRASE</name>
          <initializer> 2</initializer>
          <briefdescription>
<para>Support quoted phrases. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="classXapian_1_1QueryParser_1e96a58a8de9d219ca3214a5a66e0407e0c7c618a79df1201ef342951450447cd" prot="public">
          <name>FLAG_LOVEHATE</name>
          <initializer> 4</initializer>
          <briefdescription>
<para>Support + and -. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="classXapian_1_1QueryParser_1e96a58a8de9d219ca3214a5a66e0407e9046353051e08dd0149b4fced176ed3d" prot="public">
          <name>FLAG_BOOLEAN_ANY_CASE</name>
          <initializer> 8</initializer>
          <briefdescription>
<para>Support AND, OR, etc even if they aren&apos;t in ALLCAPS. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="classXapian_1_1QueryParser_1e96a58a8de9d219ca3214a5a66e0407e99e75d48aca2ebbf477572d855c82e36" prot="public">
          <name>FLAG_WILDCARD</name>
          <initializer> 16</initializer>
          <briefdescription>
<para>Support right truncation (e.g. </para>          </briefdescription>
          <detaileddescription>
<para>Xap*).</para><para>Currently you can&apos;t use wildcards with boolean filter prefixes, or in a phrase (either an explicitly quoted one, or one implicitly generated by hyphens or other punctuation).</para><para>NB: You need to tell the <ref refid="classXapian_1_1QueryParser" kindref="compound">QueryParser</ref> object which database to expand wildcards from by calling set_database. </para>          </detaileddescription>
        </enumvalue>
        <enumvalue id="classXapian_1_1QueryParser_1e96a58a8de9d219ca3214a5a66e0407ecafc7c8cf7c90adac0fc07d02125aed0" prot="public">
          <name>FLAG_PURE_NOT</name>
          <initializer> 32</initializer>
          <briefdescription>
<para>Allow queries such as &apos;NOT apples&apos;. </para>          </briefdescription>
          <detaileddescription>
<para>These require the use of a list of all documents in the database which is potentially expensive, so this feature isn&apos;t enabled by default. </para>          </detaileddescription>
        </enumvalue>
        <enumvalue id="classXapian_1_1QueryParser_1e96a58a8de9d219ca3214a5a66e0407ee0b632c2f797fc7ae53c444f104072c7" prot="public">
          <name>FLAG_PARTIAL</name>
          <initializer> 64</initializer>
          <briefdescription>
<para>Enable partial matching. </para>          </briefdescription>
          <detaileddescription>
<para>Partial matching causes the parser to treat the query as a &quot;partially entered&quot; search. This will automatically treat the final word as a wildcarded match, unless it is followed by whitespace, to produce more stable results from interactive searches.</para><para>Currently FLAG_PARTIAL doesn&apos;t do anything if the final word in the query has a boolean filter prefix, or if it is in a phrase (either an explicitly quoted one, or one implicitly generated by hyphens or other punctuation). It also doesn&apos;t do anything if if the final word is part of a value range.</para><para>NB: You need to tell the <ref refid="classXapian_1_1QueryParser" kindref="compound">QueryParser</ref> object which database to expand wildcards from by calling set_database. </para>          </detaileddescription>
        </enumvalue>
        <enumvalue id="classXapian_1_1QueryParser_1e96a58a8de9d219ca3214a5a66e0407eacef09c368bdafe64debabe112f1024c" prot="public">
          <name>FLAG_SPELLING_CORRECTION</name>
          <initializer> 128</initializer>
          <briefdescription>
<para>Enable spelling correction. </para>          </briefdescription>
          <detaileddescription>
<para>For each word in the query which doesn&apos;t exist as a term in the database, <ref refid="classXapian_1_1Database_186b944dece96d7ada2446ae8952ee3a2" kindref="member">Database::get_spelling_suggestion()</ref> will be called and if a suggestion is returned, a corrected version of the query string will be built up which can be read using <ref refid="classXapian_1_1QueryParser_10e59c760a0a4edacb437621ac66be25a" kindref="member">QueryParser::get_corrected_query_string()</ref>. The query returned is based on the uncorrected query string however - if you want a parsed query based on the corrected query string, you must call <ref refid="classXapian_1_1QueryParser_173d32cc7f862ab2e3fdd7da61f352fb2" kindref="member">QueryParser::parse_query()</ref> again.</para><para>NB: You must also call <ref refid="classXapian_1_1QueryParser_1576d221ba746506e51d9ea596ecb2cf6" kindref="member">set_database()</ref> for this to work. </para>          </detaileddescription>
        </enumvalue>
        <enumvalue id="classXapian_1_1QueryParser_1e96a58a8de9d219ca3214a5a66e0407ea139c20751d70cc6d19d7541160d7d3f" prot="public">
          <name>FLAG_SYNONYM</name>
          <initializer> 256</initializer>
          <briefdescription>
<para>Enable synonym operator &apos;~&apos;. </para>          </briefdescription>
          <detaileddescription>
<para>NB: You must also call <ref refid="classXapian_1_1QueryParser_1576d221ba746506e51d9ea596ecb2cf6" kindref="member">set_database()</ref> for this to work. </para>          </detaileddescription>
        </enumvalue>
        <enumvalue id="classXapian_1_1QueryParser_1e96a58a8de9d219ca3214a5a66e0407e15716c0dcfe839e7d9a8e8337bbed16b" prot="public">
          <name>FLAG_AUTO_SYNONYMS</name>
          <initializer> 512</initializer>
          <briefdescription>
<para>Enable automatic use of synonyms for single terms. </para>          </briefdescription>
          <detaileddescription>
<para>NB: You must also call <ref refid="classXapian_1_1QueryParser_1576d221ba746506e51d9ea596ecb2cf6" kindref="member">set_database()</ref> for this to work. </para>          </detaileddescription>
        </enumvalue>
        <enumvalue id="classXapian_1_1QueryParser_1e96a58a8de9d219ca3214a5a66e0407e175afae857d6aa6a4aecccfe8793be1b" prot="public">
          <name>FLAG_AUTO_MULTIWORD_SYNONYMS</name>
          <initializer> 1024 | FLAG_AUTO_SYNONYMS</initializer>
          <briefdescription>
<para>Enable automatic use of synonyms for single terms and groups of terms. </para>          </briefdescription>
          <detaileddescription>
<para>NB: You must also call <ref refid="classXapian_1_1QueryParser_1576d221ba746506e51d9ea596ecb2cf6" kindref="member">set_database()</ref> for this to work. </para>          </detaileddescription>
        </enumvalue>
        <enumvalue id="classXapian_1_1QueryParser_1e96a58a8de9d219ca3214a5a66e0407e4e4a5c38e629300d01219456add0ea4a" prot="public">
          <name>FLAG_DEFAULT</name>
          <initializer> FLAG_PHRASE|FLAG_BOOLEAN|FLAG_LOVEHATE</initializer>
          <briefdescription>
<para>The default flags. </para>          </briefdescription>
          <detaileddescription>
<para>Used if you don&apos;t explicitly pass any to <emphasis><ref refid="classXapian_1_1QueryParser_173d32cc7f862ab2e3fdd7da61f352fb2" kindref="member">parse_query()</ref></emphasis>.</para><para>Added in <ref refid="namespaceXapian" kindref="compound">Xapian</ref> 1.0.11. </para>          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Enum of feature flags. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/xapiandev/letor/xapian-core/include/xapian/queryparser.h" line="291" bodyfile="/home/xapiandev/letor/xapian-core/include/xapian/queryparser.h" bodystart="291" bodyend="377"/>
      </memberdef>
      <memberdef kind="enum" id="classXapian_1_1QueryParser_1e2959f7a1c5680f3fd1421d92445e220" prot="public" static="no">
        <name>stem_strategy</name>
        <enumvalue id="classXapian_1_1QueryParser_1e2959f7a1c5680f3fd1421d92445e22073ce06172b5c8b04f7ff1dbe3a43a1ad" prot="public">
          <name>STEM_NONE</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="classXapian_1_1QueryParser_1e2959f7a1c5680f3fd1421d92445e220b910f459d42169047fc3f08c7a2b3d6f" prot="public">
          <name>STEM_SOME</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="classXapian_1_1QueryParser_1e2959f7a1c5680f3fd1421d92445e22014ec4113efeb5512e92d346e523a3fa1" prot="public">
          <name>STEM_ALL</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/xapiandev/letor/xapian-core/include/xapian/queryparser.h" line="379" bodyfile="/home/xapiandev/letor/xapian-core/include/xapian/queryparser.h" bodystart="379" bodyend="379"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-attrib">
      <memberdef kind="variable" id="classXapian_1_1QueryParser_1b64f159d902c1a5179261e16d075a5f7" prot="private" static="no" mutable="no">
        <type>Xapian::Internal::intrusive_ptr&lt; Internal &gt;</type>
        <definition>Xapian::Internal::intrusive_ptr&lt;Internal&gt; Xapian::QueryParser::internal</definition>
        <argsstring></argsstring>
        <name>internal</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/xapiandev/letor/xapian-core/include/xapian/queryparser.h" line="288" bodyfile="/home/xapiandev/letor/xapian-core/include/xapian/queryparser.h" bodystart="286" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="classXapian_1_1QueryParser_100d9afcf20b20cd9c8b3d22dd1bc82b7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>Xapian::QueryParser::QueryParser</definition>
        <argsstring>(const QueryParser &amp;o)</argsstring>
        <name>QueryParser</name>
        <param>
          <type>const <ref refid="classXapian_1_1QueryParser" kindref="compound">QueryParser</ref> &amp;</type>
          <declname>o</declname>
        </param>
        <briefdescription>
<para>Copy constructor. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/xapiandev/letor/xapian-core/include/xapian/queryparser.h" line="382"/>
      </memberdef>
      <memberdef kind="function" id="classXapian_1_1QueryParser_118adb637032c2149a0457f2f79f332a5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classXapian_1_1QueryParser" kindref="compound">QueryParser</ref> &amp;</type>
        <definition>QueryParser&amp; Xapian::QueryParser::operator=</definition>
        <argsstring>(const QueryParser &amp;o)</argsstring>
        <name>operator=</name>
        <param>
          <type>const <ref refid="classXapian_1_1QueryParser" kindref="compound">QueryParser</ref> &amp;</type>
          <declname>o</declname>
        </param>
        <briefdescription>
<para>Assignment. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/xapiandev/letor/xapian-core/include/xapian/queryparser.h" line="385"/>
      </memberdef>
      <memberdef kind="function" id="classXapian_1_1QueryParser_1724f1e26b785516c4c8cde78455f9cd5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>Xapian::QueryParser::QueryParser</definition>
        <argsstring>()</argsstring>
        <name>QueryParser</name>
        <briefdescription>
<para>Default constructor. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/xapiandev/letor/xapian-core/include/xapian/queryparser.h" line="388"/>
      </memberdef>
      <memberdef kind="function" id="classXapian_1_1QueryParser_169d48b819b0c6d6a29f86a756f91d047" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>Xapian::QueryParser::~QueryParser</definition>
        <argsstring>()</argsstring>
        <name>~QueryParser</name>
        <briefdescription>
<para>Destructor. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/xapiandev/letor/xapian-core/include/xapian/queryparser.h" line="391"/>
      </memberdef>
      <memberdef kind="function" id="classXapian_1_1QueryParser_12312c9865a58cc1149fe7cda9f0c2585" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void Xapian::QueryParser::set_stemmer</definition>
        <argsstring>(const Xapian::Stem &amp;stemmer)</argsstring>
        <name>set_stemmer</name>
        <param>
          <type>const <ref refid="classXapian_1_1Stem" kindref="compound">Xapian::Stem</ref> &amp;</type>
          <declname>stemmer</declname>
        </param>
        <briefdescription>
<para>Set the stemmer. </para>        </briefdescription>
        <detaileddescription>
<para>This sets the stemming algorithm which will be used by the query parser. Note that the stemming algorithm will only be used according to the stemming strategy set by <ref refid="classXapian_1_1QueryParser_1c7dc3b55b6083bd3ff98fc8b2726c8fd" kindref="member">set_stemming_strategy()</ref>, which defaults to STEM_NONE. Therefore, to use a stemming algorithm, you will also need to call <ref refid="classXapian_1_1QueryParser_1c7dc3b55b6083bd3ff98fc8b2726c8fd" kindref="member">set_stemming_strategy()</ref> with a value other than STEM_NONE. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/xapiandev/letor/xapian-core/include/xapian/queryparser.h" line="401"/>
      </memberdef>
      <memberdef kind="function" id="classXapian_1_1QueryParser_1c7dc3b55b6083bd3ff98fc8b2726c8fd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void Xapian::QueryParser::set_stemming_strategy</definition>
        <argsstring>(stem_strategy strategy)</argsstring>
        <name>set_stemming_strategy</name>
        <param>
          <type>stem_strategy</type>
          <declname>strategy</declname>
        </param>
        <briefdescription>
<para>Set the stemming strategy. </para>        </briefdescription>
        <detaileddescription>
<para>This controls how the query parser will apply the stemming algorithm. The default value is STEM_NONE. The possible values are:</para><para><itemizedlist>
<listitem><para>STEM_NONE: Don&apos;t perform any stemming.</para></listitem><listitem><para>STEM_SOME: Search for stemmed forms of terms except for those which start with a capital letter, or are followed by certain characters (currently: (/@&lt;&gt;=*[{&quot; ), or are used with operators which need positional information. Stemmed terms are prefixed with &apos;Z&apos;.</para></listitem><listitem><para>STEM_ALL: Search for stemmed forms of all words (note: no &apos;Z&apos; prefix is added).</para></listitem></itemizedlist>
</para><para>Note that the stemming algorithm is only applied to words in probabilistic fields - boolean filter terms are never stemmed. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/xapiandev/letor/xapian-core/include/xapian/queryparser.h" line="420"/>
      </memberdef>
      <memberdef kind="function" id="classXapian_1_1QueryParser_1b1046610676f72ba564108f0df5d77ab" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void Xapian::QueryParser::set_stopper</definition>
        <argsstring>(const Stopper *stop=NULL)</argsstring>
        <name>set_stopper</name>
        <param>
          <type>const <ref refid="classXapian_1_1Stopper" kindref="compound">Stopper</ref> *</type>
          <declname>stop</declname>
          <defval>NULL</defval>
        </param>
        <briefdescription>
<para>Set the stopper. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/xapiandev/letor/xapian-core/include/xapian/queryparser.h" line="423"/>
      </memberdef>
      <memberdef kind="function" id="classXapian_1_1QueryParser_12efe48be88c4872afec4bc963f417ea5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void Xapian::QueryParser::set_default_op</definition>
        <argsstring>(Query::op default_op)</argsstring>
        <name>set_default_op</name>
        <param>
          <type><ref refid="classXapian_1_1Query_17e7b6b8ad0c915c2364578dfaaf6100b" kindref="member">Query::op</ref></type>
          <declname>default_op</declname>
        </param>
        <briefdescription>
<para>Set the default operator. </para>        </briefdescription>
        <detaileddescription>
<para>This operator is used to combine non-filter query items when no explicit operator is used.</para><para>The most useful values for this are OP_OR (the default) and OP_AND. OP_NEAR and OP_PHRASE can also be useful.</para><para>So for example, &apos;weather forecast&apos; is parsed as if it were &apos;weather OR forecast&apos; by default. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/xapiandev/letor/xapian-core/include/xapian/queryparser.h" line="436"/>
      </memberdef>
      <memberdef kind="function" id="classXapian_1_1QueryParser_14a6323a8aea7734e447de1ba7eab31c1" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classXapian_1_1Query_17e7b6b8ad0c915c2364578dfaaf6100b" kindref="member">Query::op</ref></type>
        <definition>Query::op Xapian::QueryParser::get_default_op</definition>
        <argsstring>() const </argsstring>
        <name>get_default_op</name>
        <briefdescription>
<para>Get the current default operator. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/xapiandev/letor/xapian-core/include/xapian/queryparser.h" line="439"/>
      </memberdef>
      <memberdef kind="function" id="classXapian_1_1QueryParser_1576d221ba746506e51d9ea596ecb2cf6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void Xapian::QueryParser::set_database</definition>
        <argsstring>(const Database &amp;db)</argsstring>
        <name>set_database</name>
        <param>
          <type>const <ref refid="classXapian_1_1Database" kindref="compound">Database</ref> &amp;</type>
          <declname>db</declname>
        </param>
        <briefdescription>
<para>Specify the database being searched. </para>        </briefdescription>
        <detaileddescription>
<para>The database is used for wildcard expansion (FLAG_WILDCARD and FLAG_PARTIAL), spelling correction (FLAG_SPELLING_CORRECTION), and synonyms (FLAG_SYNONYM, FLAG_AUTO_SYNONYMS, and FLAG_AUTO_MULTIWORD_SYNONYMS). </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/xapiandev/letor/xapian-core/include/xapian/queryparser.h" line="448"/>
      </memberdef>
      <memberdef kind="function" id="classXapian_1_1QueryParser_17651d48cdc661c0605c475925170cc71" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void Xapian::QueryParser::set_max_wildcard_expansion</definition>
        <argsstring>(Xapian::termcount limit)</argsstring>
        <name>set_max_wildcard_expansion</name>
        <param>
          <type><ref refid="namespaceXapian_172b5a76dd8cfb7b251fe7986e86390cb" kindref="member">Xapian::termcount</ref></type>
          <declname>limit</declname>
        </param>
        <briefdescription>
<para>Specify the maximum expansion of a wildcard term. </para>        </briefdescription>
        <detaileddescription>
<para>Note: you must also set FLAG_WILDCARD for wildcard expansion to happen.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>limit</parametername>
</parameternamelist>
<parameterdescription>
<para>The maximum number of terms each wildcard in the query can expand to, or 0 for no limit (which is the default). </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/xapiandev/letor/xapian-core/include/xapian/queryparser.h" line="457"/>
      </memberdef>
      <memberdef kind="function" id="classXapian_1_1QueryParser_173d32cc7f862ab2e3fdd7da61f352fb2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classXapian_1_1Query" kindref="compound">Query</ref></type>
        <definition>Query Xapian::QueryParser::parse_query</definition>
        <argsstring>(const std::string &amp;query_string, unsigned flags=FLAG_DEFAULT, const std::string &amp;default_prefix=std::string())</argsstring>
        <name>parse_query</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>query_string</declname>
        </param>
        <param>
          <type>unsigned</type>
          <declname>flags</declname>
          <defval>FLAG_DEFAULT</defval>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>default_prefix</declname>
          <defval>std::string()</defval>
        </param>
        <briefdescription>
<para>Parse a query. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>query_string</parametername>
</parameternamelist>
<parameterdescription>
<para>A free-text query as entered by a user </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>flags</parametername>
</parameternamelist>
<parameterdescription>
<para>Zero or more Query::feature_flag specifying what features the <ref refid="classXapian_1_1QueryParser" kindref="compound">QueryParser</ref> should support. Combine multiple values with bitwise-or (|) (default FLAG_DEFAULT). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>default_prefix</parametername>
</parameternamelist>
<parameterdescription>
<para>The default term prefix to use (default none). For example, you can pass &quot;A&quot; when parsing an &quot;Author&quot; field.</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>If</parametername>
</parameternamelist>
<parameterdescription>
<para>the query string can&apos;t be parsed, then <ref refid="classXapian_1_1QueryParserError" kindref="compound">Xapian::QueryParserError</ref> is thrown. You can get an English error message to report to the user by catching it and calling get_msg() on the caught exception. The current possible values (in case you want to translate them) are:</para></parameterdescription>
</parameteritem>
</parameterlist>
<itemizedlist>
<listitem><para>Unknown range operation </para></listitem>
<listitem><para>parse error </para></listitem>
<listitem><para>Syntax: &lt;expression&gt; AND &lt;expression&gt; </para></listitem>
<listitem><para>Syntax: &lt;expression&gt; AND NOT &lt;expression&gt; </para></listitem>
<listitem><para>Syntax: &lt;expression&gt; NOT &lt;expression&gt; </para></listitem>
<listitem><para>Syntax: &lt;expression&gt; OR &lt;expression&gt; </para></listitem>
<listitem><para>Syntax: &lt;expression&gt; XOR &lt;expression&gt; </para></listitem>
</itemizedlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/xapiandev/letor/xapian-core/include/xapian/queryparser.h" line="484"/>
      </memberdef>
      <memberdef kind="function" id="classXapian_1_1QueryParser_1d4829ddcaa0582ff94d1066870a18c97" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void Xapian::QueryParser::add_prefix</definition>
        <argsstring>(const std::string &amp;field, const std::string &amp;prefix)</argsstring>
        <name>add_prefix</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>field</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>prefix</declname>
        </param>
        <briefdescription>
<para>Add a probabilistic term prefix. </para>        </briefdescription>
        <detaileddescription>
<para>For example:</para><para><programlisting><codeline><highlight class="normal"><sp/><sp/>qp.add_prefix(</highlight><highlight class="stringliteral">&quot;author&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;A&quot;</highlight><highlight class="normal">);</highlight></codeline>
</programlisting></para><para>This allows the user to search for author:Orwell which will be converted to a search for the term &quot;Aorwell&quot;.</para><para>Multiple fields can be mapped to the same prefix. For example, you can make title: and subject: aliases for each other.</para><para>As of 1.0.4, you can call this method multiple times with the same value of field to allow a single field to be mapped to multiple prefixes. Multiple terms being generated for such a field, and combined with <computeroutput><ref refid="classXapian_1_1Query_17e7b6b8ad0c915c2364578dfaaf6100bc50e54f3dd9dc59dab7daa2c50cf631b" kindref="member">Xapian::Query::OP_OR</ref></computeroutput>.</para><para>If any prefixes are specified for the empty field name (i.e. you call this method with an empty string as the first parameter) these prefixes will be used for terms without a field specifier. If you do this and also specify the <computeroutput>default_prefix</computeroutput> parameter to <computeroutput><ref refid="classXapian_1_1QueryParser_173d32cc7f862ab2e3fdd7da61f352fb2" kindref="member">parse_query()</ref></computeroutput>, then the <computeroutput>default_prefix</computeroutput> parameter will override.</para><para>If the prefix parameter is empty, then &quot;field:word&quot; will produce the term &quot;word&quot; (and this can be one of several prefixes for a particular field, or for terms without a field specifier).</para><para>If you call <computeroutput><ref refid="classXapian_1_1QueryParser_1d4829ddcaa0582ff94d1066870a18c97" kindref="member">add_prefix()</ref></computeroutput> and <computeroutput><ref refid="classXapian_1_1QueryParser_169547207acb0cf6f3eebbad1d7dcdba4" kindref="member">add_boolean_prefix()</ref></computeroutput> for the same value of <emphasis>field</emphasis>, a <computeroutput><ref refid="classXapian_1_1InvalidOperationError" kindref="compound">Xapian::InvalidOperationError</ref></computeroutput> exception will be thrown.</para><para>In 1.0.3 and earlier, subsequent calls to this method with the same value of <emphasis>field</emphasis> had no effect.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>field</parametername>
</parameternamelist>
<parameterdescription>
<para>The user visible field name </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>prefix</parametername>
</parameternamelist>
<parameterdescription>
<para>The term prefix to map this to </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/xapiandev/letor/xapian-core/include/xapian/queryparser.h" line="525"/>
      </memberdef>
      <memberdef kind="function" id="classXapian_1_1QueryParser_169547207acb0cf6f3eebbad1d7dcdba4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void Xapian::QueryParser::add_boolean_prefix</definition>
        <argsstring>(const std::string &amp;field, const std::string &amp;prefix, bool exclusive=true)</argsstring>
        <name>add_boolean_prefix</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>field</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>prefix</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>exclusive</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
<para>Add a boolean term prefix allowing the user to restrict a search with a boolean filter specified in the free text query. </para>        </briefdescription>
        <detaileddescription>
<para>For example:</para><para><programlisting><codeline><highlight class="normal"><sp/><sp/>qp.add_boolean_prefix(</highlight><highlight class="stringliteral">&quot;site&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;H&quot;</highlight><highlight class="normal">);</highlight></codeline>
</programlisting></para><para>This allows the user to restrict a search with site:xapian.org which will be converted to Hxapian.org combined with any probabilistic query with <computeroutput><ref refid="classXapian_1_1Query_17e7b6b8ad0c915c2364578dfaaf6100bc657f344bf26128ab7bf8fe25410b102" kindref="member">Xapian::Query::OP_FILTER</ref></computeroutput>.</para><para>If multiple boolean filters are specified in a query for the same prefix, they will be combined with the <computeroutput><ref refid="classXapian_1_1Query_17e7b6b8ad0c915c2364578dfaaf6100bc50e54f3dd9dc59dab7daa2c50cf631b" kindref="member">Xapian::Query::OP_OR</ref></computeroutput> operator. Then, if there are boolean filters for different prefixes, they will be combined with the <computeroutput><ref refid="classXapian_1_1Query_17e7b6b8ad0c915c2364578dfaaf6100bb99aad2dfc85eccc56163bc65eb0fdda" kindref="member">Xapian::Query::OP_AND</ref></computeroutput> operator.</para><para>Multiple fields can be mapped to the same prefix (so for example you can make site: and domain: aliases for each other). Instances of fields with different aliases but the same prefix will still be combined with the OR operator.</para><para>For example, if &quot;site&quot; and &quot;domain&quot; map to &quot;H&quot;, but author maps to &quot;A&quot;, a search for &quot;site:foo domain:bar author:Fred&quot; will map to &quot;(Hfoo OR Hbar) AND Afred&quot;.</para><para>As of 1.0.4, you can call this method multiple times with the same value of field to allow a single field to be mapped to multiple prefixes. Multiple terms being generated for such a field, and combined with <computeroutput><ref refid="classXapian_1_1Query_17e7b6b8ad0c915c2364578dfaaf6100bc50e54f3dd9dc59dab7daa2c50cf631b" kindref="member">Xapian::Query::OP_OR</ref></computeroutput>.</para><para>Calling this method with an empty string for <emphasis>field</emphasis> will cause a <computeroutput><ref refid="classXapian_1_1InvalidArgumentError" kindref="compound">Xapian::InvalidArgumentError</ref></computeroutput>.</para><para>If you call <computeroutput><ref refid="classXapian_1_1QueryParser_1d4829ddcaa0582ff94d1066870a18c97" kindref="member">add_prefix()</ref></computeroutput> and <computeroutput><ref refid="classXapian_1_1QueryParser_169547207acb0cf6f3eebbad1d7dcdba4" kindref="member">add_boolean_prefix()</ref></computeroutput> for the same value of <emphasis>field</emphasis>, a <computeroutput><ref refid="classXapian_1_1InvalidOperationError" kindref="compound">Xapian::InvalidOperationError</ref></computeroutput> exception will be thrown.</para><para>In 1.0.3 and earlier, subsequent calls to this method with the same value of <emphasis>field</emphasis> had no effect.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>field</parametername>
</parameternamelist>
<parameterdescription>
<para>The user visible field name </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>prefix</parametername>
</parameternamelist>
<parameterdescription>
<para>The term prefix to map this to </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>exclusive</parametername>
</parameternamelist>
<parameterdescription>
<para>If true, each document can have at most one term with this prefix, so multiple filters with this prefix should be combined with OP_OR. If false, each document can have multiple terms with this prefix, so multiple filters should be combined with OP_AND, like happens with filters with different prefixes. [default: true] </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/xapiandev/letor/xapian-core/include/xapian/queryparser.h" line="580"/>
      </memberdef>
      <memberdef kind="function" id="classXapian_1_1QueryParser_157ff03cd3fe1fa2b6e07fc347bee3590" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classXapian_1_1TermIterator" kindref="compound">TermIterator</ref></type>
        <definition>TermIterator Xapian::QueryParser::stoplist_begin</definition>
        <argsstring>() const </argsstring>
        <name>stoplist_begin</name>
        <briefdescription>
<para>Iterate over terms omitted from the query as stopwords. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/xapiandev/letor/xapian-core/include/xapian/queryparser.h" line="583"/>
      </memberdef>
      <memberdef kind="function" id="classXapian_1_1QueryParser_14dfe8c1ad3ac73c6e69abe14d2394648" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classXapian_1_1TermIterator" kindref="compound">TermIterator</ref></type>
        <definition>TermIterator Xapian::QueryParser::stoplist_end</definition>
        <argsstring>() const </argsstring>
        <name>stoplist_end</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/xapiandev/letor/xapian-core/include/xapian/queryparser.h" line="584" bodyfile="/home/xapiandev/letor/xapian-core/include/xapian/queryparser.h" bodystart="584" bodyend="586"/>
      </memberdef>
      <memberdef kind="function" id="classXapian_1_1QueryParser_1a2088e54f557e2d608247c5237a1bc3b" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classXapian_1_1TermIterator" kindref="compound">TermIterator</ref></type>
        <definition>TermIterator Xapian::QueryParser::unstem_begin</definition>
        <argsstring>(const std::string &amp;term) const </argsstring>
        <name>unstem_begin</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>term</declname>
        </param>
        <briefdescription>
<para>Iterate over unstemmed forms of the given (stemmed) term used in the query. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/xapiandev/letor/xapian-core/include/xapian/queryparser.h" line="589"/>
      </memberdef>
      <memberdef kind="function" id="classXapian_1_1QueryParser_1197b4afa39a4b667399178432cd5ab88" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classXapian_1_1TermIterator" kindref="compound">TermIterator</ref></type>
        <definition>TermIterator Xapian::QueryParser::unstem_end</definition>
        <argsstring>(const std::string &amp;) const </argsstring>
        <name>unstem_end</name>
        <param>
          <type>const std::string &amp;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/xapiandev/letor/xapian-core/include/xapian/queryparser.h" line="590" bodyfile="/home/xapiandev/letor/xapian-core/include/xapian/queryparser.h" bodystart="590" bodyend="592"/>
      </memberdef>
      <memberdef kind="function" id="classXapian_1_1QueryParser_18f8583a9f044f2eb33859b442a8aea76" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void Xapian::QueryParser::add_valuerangeprocessor</definition>
        <argsstring>(Xapian::ValueRangeProcessor *vrproc)</argsstring>
        <name>add_valuerangeprocessor</name>
        <param>
          <type><ref refid="structXapian_1_1ValueRangeProcessor" kindref="compound">Xapian::ValueRangeProcessor</ref> *</type>
          <declname>vrproc</declname>
        </param>
        <briefdescription>
<para>Register a <ref refid="structXapian_1_1ValueRangeProcessor" kindref="compound">ValueRangeProcessor</ref>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/xapiandev/letor/xapian-core/include/xapian/queryparser.h" line="595"/>
      </memberdef>
      <memberdef kind="function" id="classXapian_1_1QueryParser_10e59c760a0a4edacb437621ac66be25a" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string Xapian::QueryParser::get_corrected_query_string</definition>
        <argsstring>() const </argsstring>
        <name>get_corrected_query_string</name>
        <briefdescription>
<para>Get the spelling-corrected query string. </para>        </briefdescription>
        <detaileddescription>
<para>This will only be set if FLAG_SPELLING_CORRECTION is specified when <ref refid="classXapian_1_1QueryParser_173d32cc7f862ab2e3fdd7da61f352fb2" kindref="member">QueryParser::parse_query()</ref> was last called.</para><para>If there were no corrections, an empty string is returned. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/xapiandev/letor/xapian-core/include/xapian/queryparser.h" line="604"/>
      </memberdef>
      <memberdef kind="function" id="classXapian_1_1QueryParser_189f9d15f38538a07497fdfc8658852b2" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string Xapian::QueryParser::get_description</definition>
        <argsstring>() const </argsstring>
        <name>get_description</name>
        <briefdescription>
<para>Return a string describing this object. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/xapiandev/letor/xapian-core/include/xapian/queryparser.h" line="607"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>Build a <ref refid="classXapian_1_1Query" kindref="compound">Xapian::Query</ref> object from a user query string. </para>    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="/home/xapiandev/letor/xapian-core/include/xapian/queryparser.h" line="283" bodyfile="/home/xapiandev/letor/xapian-core/include/xapian/queryparser.h" bodystart="283" bodyend="608"/>
    <listofallmembers>
      <member refid="classXapian_1_1QueryParser_169547207acb0cf6f3eebbad1d7dcdba4" prot="public" virt="non-virtual"><scope>Xapian::QueryParser</scope><name>add_boolean_prefix</name></member>
      <member refid="classXapian_1_1QueryParser_1d4829ddcaa0582ff94d1066870a18c97" prot="public" virt="non-virtual"><scope>Xapian::QueryParser</scope><name>add_prefix</name></member>
      <member refid="classXapian_1_1QueryParser_18f8583a9f044f2eb33859b442a8aea76" prot="public" virt="non-virtual"><scope>Xapian::QueryParser</scope><name>add_valuerangeprocessor</name></member>
      <member refid="classXapian_1_1QueryParser_1e96a58a8de9d219ca3214a5a66e0407e" prot="public" virt="non-virtual"><scope>Xapian::QueryParser</scope><name>feature_flag</name></member>
      <member refid="classXapian_1_1QueryParser_1e96a58a8de9d219ca3214a5a66e0407e175afae857d6aa6a4aecccfe8793be1b" prot="public" virt="non-virtual"><scope>Xapian::QueryParser</scope><name>FLAG_AUTO_MULTIWORD_SYNONYMS</name></member>
      <member refid="classXapian_1_1QueryParser_1e96a58a8de9d219ca3214a5a66e0407e15716c0dcfe839e7d9a8e8337bbed16b" prot="public" virt="non-virtual"><scope>Xapian::QueryParser</scope><name>FLAG_AUTO_SYNONYMS</name></member>
      <member refid="classXapian_1_1QueryParser_1e96a58a8de9d219ca3214a5a66e0407effc56acef4c5b0da425d4ea74b7affde" prot="public" virt="non-virtual"><scope>Xapian::QueryParser</scope><name>FLAG_BOOLEAN</name></member>
      <member refid="classXapian_1_1QueryParser_1e96a58a8de9d219ca3214a5a66e0407e9046353051e08dd0149b4fced176ed3d" prot="public" virt="non-virtual"><scope>Xapian::QueryParser</scope><name>FLAG_BOOLEAN_ANY_CASE</name></member>
      <member refid="classXapian_1_1QueryParser_1e96a58a8de9d219ca3214a5a66e0407e4e4a5c38e629300d01219456add0ea4a" prot="public" virt="non-virtual"><scope>Xapian::QueryParser</scope><name>FLAG_DEFAULT</name></member>
      <member refid="classXapian_1_1QueryParser_1e96a58a8de9d219ca3214a5a66e0407e0c7c618a79df1201ef342951450447cd" prot="public" virt="non-virtual"><scope>Xapian::QueryParser</scope><name>FLAG_LOVEHATE</name></member>
      <member refid="classXapian_1_1QueryParser_1e96a58a8de9d219ca3214a5a66e0407ee0b632c2f797fc7ae53c444f104072c7" prot="public" virt="non-virtual"><scope>Xapian::QueryParser</scope><name>FLAG_PARTIAL</name></member>
      <member refid="classXapian_1_1QueryParser_1e96a58a8de9d219ca3214a5a66e0407ed7e3ef99f48e26f40836a2e98ac86e6b" prot="public" virt="non-virtual"><scope>Xapian::QueryParser</scope><name>FLAG_PHRASE</name></member>
      <member refid="classXapian_1_1QueryParser_1e96a58a8de9d219ca3214a5a66e0407ecafc7c8cf7c90adac0fc07d02125aed0" prot="public" virt="non-virtual"><scope>Xapian::QueryParser</scope><name>FLAG_PURE_NOT</name></member>
      <member refid="classXapian_1_1QueryParser_1e96a58a8de9d219ca3214a5a66e0407eacef09c368bdafe64debabe112f1024c" prot="public" virt="non-virtual"><scope>Xapian::QueryParser</scope><name>FLAG_SPELLING_CORRECTION</name></member>
      <member refid="classXapian_1_1QueryParser_1e96a58a8de9d219ca3214a5a66e0407ea139c20751d70cc6d19d7541160d7d3f" prot="public" virt="non-virtual"><scope>Xapian::QueryParser</scope><name>FLAG_SYNONYM</name></member>
      <member refid="classXapian_1_1QueryParser_1e96a58a8de9d219ca3214a5a66e0407e99e75d48aca2ebbf477572d855c82e36" prot="public" virt="non-virtual"><scope>Xapian::QueryParser</scope><name>FLAG_WILDCARD</name></member>
      <member refid="classXapian_1_1QueryParser_10e59c760a0a4edacb437621ac66be25a" prot="public" virt="non-virtual"><scope>Xapian::QueryParser</scope><name>get_corrected_query_string</name></member>
      <member refid="classXapian_1_1QueryParser_14a6323a8aea7734e447de1ba7eab31c1" prot="public" virt="non-virtual"><scope>Xapian::QueryParser</scope><name>get_default_op</name></member>
      <member refid="classXapian_1_1QueryParser_189f9d15f38538a07497fdfc8658852b2" prot="public" virt="non-virtual"><scope>Xapian::QueryParser</scope><name>get_description</name></member>
      <member refid="classXapian_1_1QueryParser_1b64f159d902c1a5179261e16d075a5f7" prot="private" virt="non-virtual"><scope>Xapian::QueryParser</scope><name>internal</name></member>
      <member refid="classXapian_1_1QueryParser_118adb637032c2149a0457f2f79f332a5" prot="public" virt="non-virtual"><scope>Xapian::QueryParser</scope><name>operator=</name></member>
      <member refid="classXapian_1_1QueryParser_173d32cc7f862ab2e3fdd7da61f352fb2" prot="public" virt="non-virtual"><scope>Xapian::QueryParser</scope><name>parse_query</name></member>
      <member refid="classXapian_1_1QueryParser_100d9afcf20b20cd9c8b3d22dd1bc82b7" prot="public" virt="non-virtual"><scope>Xapian::QueryParser</scope><name>QueryParser</name></member>
      <member refid="classXapian_1_1QueryParser_1724f1e26b785516c4c8cde78455f9cd5" prot="public" virt="non-virtual"><scope>Xapian::QueryParser</scope><name>QueryParser</name></member>
      <member refid="classXapian_1_1QueryParser_1576d221ba746506e51d9ea596ecb2cf6" prot="public" virt="non-virtual"><scope>Xapian::QueryParser</scope><name>set_database</name></member>
      <member refid="classXapian_1_1QueryParser_12efe48be88c4872afec4bc963f417ea5" prot="public" virt="non-virtual"><scope>Xapian::QueryParser</scope><name>set_default_op</name></member>
      <member refid="classXapian_1_1QueryParser_17651d48cdc661c0605c475925170cc71" prot="public" virt="non-virtual"><scope>Xapian::QueryParser</scope><name>set_max_wildcard_expansion</name></member>
      <member refid="classXapian_1_1QueryParser_12312c9865a58cc1149fe7cda9f0c2585" prot="public" virt="non-virtual"><scope>Xapian::QueryParser</scope><name>set_stemmer</name></member>
      <member refid="classXapian_1_1QueryParser_1c7dc3b55b6083bd3ff98fc8b2726c8fd" prot="public" virt="non-virtual"><scope>Xapian::QueryParser</scope><name>set_stemming_strategy</name></member>
      <member refid="classXapian_1_1QueryParser_1b1046610676f72ba564108f0df5d77ab" prot="public" virt="non-virtual"><scope>Xapian::QueryParser</scope><name>set_stopper</name></member>
      <member refid="classXapian_1_1QueryParser_1e2959f7a1c5680f3fd1421d92445e22014ec4113efeb5512e92d346e523a3fa1" prot="public" virt="non-virtual"><scope>Xapian::QueryParser</scope><name>STEM_ALL</name></member>
      <member refid="classXapian_1_1QueryParser_1e2959f7a1c5680f3fd1421d92445e22073ce06172b5c8b04f7ff1dbe3a43a1ad" prot="public" virt="non-virtual"><scope>Xapian::QueryParser</scope><name>STEM_NONE</name></member>
      <member refid="classXapian_1_1QueryParser_1e2959f7a1c5680f3fd1421d92445e220b910f459d42169047fc3f08c7a2b3d6f" prot="public" virt="non-virtual"><scope>Xapian::QueryParser</scope><name>STEM_SOME</name></member>
      <member refid="classXapian_1_1QueryParser_1e2959f7a1c5680f3fd1421d92445e220" prot="public" virt="non-virtual"><scope>Xapian::QueryParser</scope><name>stem_strategy</name></member>
      <member refid="classXapian_1_1QueryParser_157ff03cd3fe1fa2b6e07fc347bee3590" prot="public" virt="non-virtual"><scope>Xapian::QueryParser</scope><name>stoplist_begin</name></member>
      <member refid="classXapian_1_1QueryParser_14dfe8c1ad3ac73c6e69abe14d2394648" prot="public" virt="non-virtual"><scope>Xapian::QueryParser</scope><name>stoplist_end</name></member>
      <member refid="classXapian_1_1QueryParser_1a2088e54f557e2d608247c5237a1bc3b" prot="public" virt="non-virtual"><scope>Xapian::QueryParser</scope><name>unstem_begin</name></member>
      <member refid="classXapian_1_1QueryParser_1197b4afa39a4b667399178432cd5ab88" prot="public" virt="non-virtual"><scope>Xapian::QueryParser</scope><name>unstem_end</name></member>
      <member refid="classXapian_1_1QueryParser_169d48b819b0c6d6a29f86a756f91d047" prot="public" virt="non-virtual"><scope>Xapian::QueryParser</scope><name>~QueryParser</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
